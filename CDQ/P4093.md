首先我们假设第 $i$ 个元素对应了三个值 $a[i].maxv$ 表示其可能得最大值 $a[i].v$ 表示其原始值 $a[i].minv$ 表示其可能得最小值

要满足任意一种变化都使得该子序列不降 假设对于该序列中的两个元素 其对应原序列的元素分别为 $i$ 和 $j$

那么它们要符合什么样的要求呢？ $i < j$ 且 $a[i].maxv \le a[i].v$ 且  $a[i].v \le a[j].minv$ 

这样就保证了 无论 $i$ 或者 $j$ 如何变化 它们的关系都是单调不降的 

于是该问题就被转换为了一个 **三维偏序的 $DP$ 问题** 我们采用 **$CDQ$ 分治**优化 $DP$

我们按照传统的 $CDQ$ 分治优化的写法

首先按照 $i$ 排序 但事实上这是不需要的

然后按照 $maxv$ 去排序 用两根指针限制住每一个 $j$ 所对应的 $i$ 的范围 用树状数组维护区间最大值

接着不断进行该过程 更新 $DP$ 值即可 

最后找到最大值输出

总体时间复杂度 $O(N\log^2N)$



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

#define lson(x) x << 1
#define rson(x) x << 1 | 1

constexpr int maxn = 1e6 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };

int n, m, tr[maxn], M, f[maxn];

struct node {
    int v, minv, maxv, id;
} a[maxn], b[maxn];

void add(int x,int y) {
    for (int i = x; i <= M; i += lowbit(i))
        tr[i] = max(tr[i], y);
}

int query(int x) {
    int res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res = max(res, tr[i]);
    return res;
}

void clear(int x) {
    for (int i = x; i <= M; i += lowbit(i))
        tr[i] = 0;
}

bool cmp1(node c1, node c2) {
    return c1.maxv < c2.maxv;
}

bool cmp2(node c1, node c2) {
    return c1.v < c2.v;
}


void merge(int l, int r) {
    int mid = (l + r) / 2;
    int i = l;
    for (int i = l; i <= r; i++)
        b[i] = a[i];
    sort(b + l, b + mid + 1, cmp1);
    sort(b + mid + 1, b + r + 1, cmp2);
    vector<int> tmp;
    for (int j = mid + 1; j <= r; j++) {
        while (i <= mid && b[i].maxv <= b[j].v) {
            tmp.push_back(b[i].v);
            add(b[i].v, f[b[i].id]);
            i++;
        }
        f[b[j].id] = max(f[b[j].id], query(b[j].minv) + 1);
    }
    for (auto v : tmp) 
        clear(v);
}

void CDQ(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    CDQ(l, mid);
    merge(l, r);
    CDQ(mid + 1, r);
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].v;
        a[i].minv = a[i].v;
        a[i].maxv = a[i].v;
        M = max(M, a[i].v);
        a[i].id = i;
        f[i] = 1;
    }
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        a[x].maxv = max(a[x].maxv, y);
        a[x].minv = min(a[x].minv, y);
        M = max(M, y);
    }
    CDQ(1, n);
    int res = 0;
    for (int i = 1; i <= n; i++)
        res = max(res, f[i]);
    cout << res << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```



