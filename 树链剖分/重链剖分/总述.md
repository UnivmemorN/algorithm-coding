重链剖分 ($HLD$) 用来将树拆分成若干重链以快速维护树上路径或子树问题 通常会和线段树结合
- 对任意一个节点 $u$ 我们要得到的信息有:

​		$fa$   ：父节点

​		$dep$ ：深度

​		$siz$ ： 子树大小

​		$son$ ：重儿子, $u$ 的子树中规模最大的儿子

​		$top$ ： 所在重链的头节点

​		$dfn$ ： $DFS$ 序的编号

​		$seg$ ： $seg[i]=j$ 表示 $dfn$ 序号为 $i$ 的节点,所对应的树上节点编号为 $j$ 用于在线段树建树的时候正确的找到原数组的值

- $dfs1$ 的过程中, 我们要设置 $fa$  , $dep$ , $siz$  , $son$ ，此过程不分配 $dfn$ 序号
- $dfs2$ 的过程中,我们要设置 $top$ , $dfn$ , $seg$   遍历的方式是优先走重儿子 $son$ 再遍历剩下的轻儿子 依次分配 $dfn$ 序号 父节点和重儿子属于同一条链,具有相同的$top$ 而轻儿子会新开一条重链同时以自己为头
- 故,位于同一个重链上的所有节点的 $dfn$ 序都是连续的,同时位于同一棵子树上的节点其 $dfn$ 序号也是连续的
- 那么对子树进行操作事实上就是对线段树的单次操作 ；而对两点间的路径进行操作稍微麻烦，我们要不断向上找到多条重链,每条重链的信息都要利用线段树操作
- 对子树的操作复杂度为 $O(\log n)$  而 对路径的操作复杂度为 $O(\log^2 n)$
- 树链剖分还可以用来快速地求 $LCA$  ，让 $u$ 和 $v$ 不断向上跳跳到同一条重链，此时 $dep$ / $dfn$ 较小的点即为 $LCA$ 

另外 , 树链剖分是对点权进行操作的 , 若题目中给我们的是边权的条件，应该如何转化呢？**对于一条从 $u$ 到 $v$ 的边，假设(两者在树上的关系为) $u$ 为父亲 $v$ 为儿子，把边权转化为 $v$ 点的点权即可** 也就是说，我们可以把边权**下放**给这条边**深度较大**的节点
而在查询的时候也是一样，查询**路径上每条边的深度较大点的点权**即可


# 🌲 重链剖分（Heavy-Light Decomposition, HLD）

重链剖分用于将树拆分成若干条 **重链**，以便**快速维护树上路径或子树相关问题**。  

通常与 **线段树（Segment Tree）** 结合使用，实现树上路径的加、查、最值等操作。

---

## 一、节点需要维护的信息

| 名称     | 含义                                                  |
| -------- | ----------------------------------------------------- |
| `fa[u]`  | 父节点                                                |
| `dep[u]` | 节点深度                                              |
| `siz[u]` | 子树大小                                              |
| `son[u]` | 重儿子（子树规模最大的儿子）                          |
| `top[u]` | 所在重链的头节点                                      |
| `dfn[u]` | DFS 序编号                                            |
| `seg[i]` | DFS 序号为 `i` 的节点编号，用于线段树建树时找到原节点 |

---

## 二、两次 DFS 的作用

### 🌀 第一次 DFS（`dfs1`）

用于计算：

- `fa[u]`（父节点）
- `dep[u]`（深度）
- `siz[u]`（子树大小）
- `son[u]`（重儿子）

> ⚠️ 在此过程中 **不分配 DFS 序号**。

---

### 🌿 第二次 DFS（`dfs2`）

用于计算：

- `top[u]`（当前节点所在重链的头节点）
- `dfn[u]`（DFS 序号）
- `seg[i]`（反向映射：`dfn -> 节点编号`）

遍历方式：

1. 先访问 **重儿子** `son[u]`；
2. 再访问其余 **轻儿子**。

规则：

- 父节点与重儿子在同一条链上，`top` 相同；
- 每个轻儿子开启一条新链，`top[child] = child`。

---

## 三、DFS 序的性质

1. **同一条重链上的节点**：`dfn` 序号连续；
2. **同一棵子树内的节点**：`dfn` 序号也连续。

因此：

- 对子树操作 ⇒ 在线段树上进行单区间操作；
- 对路径操作 ⇒ 分解成若干条重链，逐条处理。

---

## 四、复杂度分析

| 操作类型     | 时间复杂度    |
| ------------ | ------------- |
| 子树操作     | $O(\log n)$   |
| 两点路径操作 | $O(\log^2 n)$ |

---

## 五、求 LCA（最近公共祖先）

树链剖分同样可用于快速求 LCA：

不断让 `u` 和 `v` **向上跳链**，直到它们处于同一条重链上。  
此时深度（或 DFS 序）较小的节点即为 LCA。

---

## 六、边权转点权的处理方法

若题目给出的是 **边权** 而非点权，可以进行如下转化：

> 对于一条边 $(u, v)$，假设 $u$ 是父亲、$v$ 是儿子，  
> 则将该边的权值 **下放到深度较大的点 $v$ 上**。

这样：

- 在线段树上只需维护点权；
- 查询路径时，只需统计 **路径上每条边深度较大的点的点权**。

---

## 七、HLD 结构图示（示意）

```text
      1
     / \
    2   3
   / \
  4   5
     / \
    6   7
```

假设 $2$ 是 $1$ 的重儿子，$5$ 是 $2$ 的重儿子；

则链划分结果为：

重链 $1$ ：$1$ → $2$ → $5$
重链 $2$ ：$3$
重链 $3$ ：$4$
重链 $4$ ：$6$
重链 $5$ ：$7$

---


| 功能                | 实现原理               | 时间复杂度    |
| ------------------- | ---------------------- | ------------- |
| 子树区间更新 / 查询 | 子树 dfn 连续          | $O(\log n)$   |
| 路径加 / 查         | 分解为若干重链区间操作 | $O(\log^2 n)$ |
| LCA 求解            | 不断上跳重链           | $O(\log n)$   |
| 边权处理            | 下放到深度较大节点     |  $O(1)$             |
