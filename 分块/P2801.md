本题有两种操作 区间 $+$ 和区间查询 $\ge C$ 的个数

区间修改 区间查询 $\le$ 或者 $\ge$ 某个数的个数 通常想到分块而非线段树

因为虽然 $push\_up$过程简单  但是在区间修改的过程中 我们是无法很好的维护好当前区间的满足条件的个数的

而分块实际上是优雅的暴力

我们将整个区间分为若干块 一开始，我们不妨假设块长$B = \sqrt{N}$

我们先预处理出块的总数和每个块的右边界 $br$ 数组

每当有一个从 $l$ 到 $r$ 区间 $+x$ 的操作时

我们根据 $l$ 所在的块号 $Bl$ 和 $r$ 所在的块号 $Br$ 

如果 $Bl = Br$ 那么说明 $l$ 和 $r$ 处于同一块 我们直接将 $l$ 到 $r$ 范围内的数字全部 $+x$ 即可

而如果 $Bl$ 和 $Br$ 不相等 那么我们把整个区间分为三部分 

首先是 $l$ 到 $br[Bl]$ 这部分散块内的部分内容

其次是 $Bl + 1$ 到 $Br - 1$ 这部分整块

最后是从 $br[Br - 1]$ 到 $r$ 这部分散块

第一部分和第三部分 我们还是直接将范围内的数字全部 $+x$ 即可

而第二部分 由于整个块全部都发生了变化 我们不妨将这些块全部打上标记 令其 $lazy$ 值全部增加 $x$ 

以后查询如果遍历到这个块中的节点 只需要让其 $+lazy$ 即可

查询我们也是同样的道理分情况去讨论

但是问题在于 整块的话 我们如何快速地找到个数呢

我们继续引入一个 $v$ 数组 其用来存储某个区间内的数组的值**按照从小到大排序后的结果**

为什么我们不能只依靠 $v$ 数组呢 因为修改的时候是按照原数组的编号的

所以这里就需要注意了 每次散块修改 修改的是原来的值而非 $v$ 数组中的值

修改完成后 当前块整个块的内容都需要重新拷贝到 $v$ 数组的对应位置 然后排序

那么我们要查询整块的时候 只需要一个二分就可以解决了

总体时间复杂度为 $O(N \sqrt{N}\log N)$



代码如下 : 

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9 + 1e8;


constexpr int maxn = 1e6 + 10;
int n, m, a[maxn], B, bl[maxn], br[maxn], b[maxn], lazy[maxn];

void prework() {
    B = sqrt(n);
    int bnum = (n - 1) / B + 1;
    for (int i = 1; i <= bnum; i++) {
        bl[i] = (i - 1) * B + 1;
        br[i] = min(i * B, n);
        sort(b + bl[i], b + br[i] + 1);
    }
}

int query(int Bnum, int x) {
    int l = bl[Bnum], r = br[Bnum], ans = -1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (b[mid] < x) l = mid + 1;
        else {
            ans = mid;
            r = mid - 1;
        }
    }
    if (ans == -1) return 0;
    return (br[Bnum] - ans + 1);
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i], b[i] = a[i];
    prework();
    for (int i = 1; i <= m; i++) {
        char op; int l, r, w;
        cin >> op >> l >> r >> w;
        int Bl = (l - 1) / B + 1;
        int Br = (r - 1) / B + 1;
        if (op == 'M') {
            if (Bl == Br) {
                for (int i = l; i <= r; i++)
                    a[i] += w, b[i] = a[i];
                for (int i = bl[Bl]; i <= br[Bl]; i++)
                    b[i] = a[i];
                sort(b + bl[Bl], b + br[Bl] + 1);
            }
            else {
                for (int i = Bl + 1; i <= Br - 1; i++)
                    lazy[i] += w;
                for (int i = l; i <= br[Bl]; i++) a[i] += w;
                for (int i = bl[Br]; i <= r; i++) a[i] += w;
                for (int i = bl[Bl]; i <= br[Bl]; i++)
                    b[i] = a[i];
                for (int i = bl[Br]; i <= br[Br]; i++)
                    b[i] = a[i];
                sort(b + bl[Bl], b + br[Bl] + 1);
                sort(b + bl[Br], b + br[Br] + 1);
            }
        }
        else {
            int sum = 0;
            if (Bl == Br) {
                for (int i = l; i <= r; i++)
                    if (a[i] + lazy[Bl] >= w) sum++;
            }
            else {
                for (int i = l; i <= br[Bl]; i++)
                    if (a[i] + lazy[Bl] >= w) sum++;
                for (int i = bl[Br]; i <= r; i++)
                    if (a[i] + lazy[Br] >= w) sum++;
                for (int i = Bl + 1; i <= Br - 1; i++)
                    sum += query(i, w - lazy[i]);
            }
            cout << sum << "\n";
        }
    }
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //prework();
    //cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

