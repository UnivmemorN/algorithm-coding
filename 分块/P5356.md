本题要维护的是 **区间 $+$** 和 **区间找第 $k$ 小**

本题和 $P2801$ 的处理方式大致相同 问题在于我们该如何找 区间第 $k$ 小

很经典的做法是**二分答案** 

我们直接去二分这个第 $k$ 小的数值是多少 假设其为 $mid$

那么我们要统计的就是区间 $[l,r]$ 中 $<=mid$ 的个数 $cnt$ 

如果 $cnt \ge k$ 那么表示比这个数小的数过多 让二分右指针 $right$ 左移即可 同时记录答案 否则让左指针 $left$ 右移

而统计区间中 $\le mid$ 的数的个数问题 正是 $P2801$ 要解决的问题 所以本题迎刃而解了



代码如下 : 

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;


constexpr int maxn = 1e5 + 10;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, m, a[maxn], B, bnum, br[maxn], v[maxn], lazy[maxn];

void prework() {
    B = sqrt(n);
    bnum = (n - 1) / B + 1;
    for (int i = 1; i <= bnum; i++)
        br[i] = min(i * B, n);
    for (int i = 1; i <= bnum; i++) {
        for (int j = br[i - 1] + 1; j <= br[i]; j++)
            v[j] = a[j];
        sort(v + br[i - 1] + 1, v + br[i] + 1);
    }
}

void add(int l, int r, int k) {
    int L = (l - 1) / B + 1, R = (r - 1) / B + 1;
    if (L == R){
        for (int i = l; i <= r; i++)
            a[i] += k;
        for (int i = br[L - 1] + 1; i <= br[L]; i++) v[i] = a[i];
        sort(v + br[L - 1] + 1, v + br[L] + 1);
    }
    else {
        for (int i = L + 1; i <= R - 1; i++) lazy[i] += k;
        for (int i = l; i <= br[L]; i++) a[i] += k;
        for (int i = br[R - 1] + 1; i <= r; i++) a[i] += k;
        for (int i = br[L - 1] + 1; i <= br[L]; i++) v[i] = a[i];
        for (int i = br[R - 1] + 1; i <= br[R]; i++) v[i] = a[i];
        sort(v + br[L - 1] + 1, v + br[L] + 1);
        sort(v + br[R - 1] + 1, v + br[R] + 1);
    }
}

int getmin(int l, int r) {
    int L = (l - 1) / B + 1, R = (r - 1) / B + 1, res = 2e9;
    if (L == R) {
        for (int i = l; i <= r; i++) 
            res = min(res, a[i] + lazy[L]);
    }
    else {
        for (int i = l; i <= br[L]; i++)
            res = min(res, a[i] + lazy[L]);
        for (int i = L + 1; i <= R - 1; i++)
            res = min(res, v[br[i - 1] + 1] + lazy[i]);
        for (int i = br[R - 1] + 1; i <= r; i++)
            res = min(res, a[i] + lazy[R]);
    }
    return res;
}

int getmax(int l, int r) {
    int L = (l - 1) / B + 1, R = (r - 1) / B + 1, res = -2e9;
    if (L == R) {
        for (int i = l; i <= r; i++)
            res = max(res, a[i] + lazy[L]);
    }
    else {
        for (int i = l; i <= br[L]; i++)
            res = max(res, a[i] + lazy[L]);
        for (int i = L + 1; i <= R - 1; i++)
            res = max(res, v[br[i]] + lazy[i]);
        for (int i = br[R - 1] + 1; i <= r; i++)
            res = max(res, a[i] + lazy[R]);
    }
    return res;
}

int cal(int l, int r, int mid) {
    int L = (l - 1) / B + 1, R = (r - 1) / B + 1;
    int res = 0;
    if (L == R) {
        for (int i = l; i <= r; i++)
            if (a[i] + lazy[L] <= mid) res++;
    }
    else {
        for (int i = l; i <= br[L]; i++)
            if (a[i] + lazy[L] <= mid) res++;
        for (int i = L + 1; i <= R - 1; i++) {
            res += upper_bound(v + br[i - 1] + 1, v + br[i] + 1, mid - lazy[i]) - (v + br[i - 1]) - 1;
        }
        for (int i = br[R - 1] + 1; i <= r; i++)
            if (a[i] + lazy[R] <= mid) res++;
    }
    return res;
}

int query(int l, int r, int k) {
    ll le = getmin(l, r), ri = getmax(l, r), ans = 0;
    while (le <= ri) {
        ll mid = (le + ri) / 2, count = cal(l, r, mid);
        if (count >= k) {
            ri = mid - 1;
            ans = mid;
        }
        else le = mid + 1;
    }
    return ans;
}

void solve(int id) {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    prework();
    while (m--) {
        int op, l, r, k;
        cin >> op >> l >> r >> k;
        if (op == 1) {
            if (r - l + 1 < k) cout << -1 << "\n";
            else cout << query(l, r, k) << "\n";
        }
        else add(l, r, k);
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

