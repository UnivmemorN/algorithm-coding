让我们回忆并查集

并查集是可以帮助我们判断某两个点是否在同一个集合的

然而在这道题中 我们仅仅知道两个点是否在同一集合中是不够的 因为题目中还存在 **吃** 的关系

那么我们可以对于一个点 记录它的三个集合 **同类** **食物** 和 **天敌**

所以我们要将原先并查集的值域 $1-n$ 扩展为 $1 - 3\times n$

那么对于一个点 $i$ 我们令其

**同类** $i$              **食物** $i + n$         **天敌** $i + 2 \times n$

我们对于操作 $1\space X\space Y$                  表示 $X$ 和 $Y$ 是同类

那么此时我们考虑什么情况下这条语句会是**假话**

只有两种情况 $X$ 是 $Y$ 的食物 或者 $X$ 是 $Y$ 的天敌

也就是说我们只需要判断 $X$ 和 $Y + n$ 是否在同一集合 $X$ 和 $Y + 2 \times n$ 是否在同一集合即可

那么如果这条语句是**真话** 既然 $X$ 和 $Y$ 是同类 

那么显然 $X$ 的食物类 也和 $Y$ 的食物类是同类 $X$ 的天敌类也和 $Y$ 的天敌类是同类

所以我们要将 $X$ 和 $Y$ 所在集合、$X + n$ 和 $Y + n$ 、所在集合 $X + 2 \times n $ 和 $Y + 2\times n$ 所在集合给合并起来

对于操作 $2\space X \space Y$            表示 $X$ 吃 $Y$ 

那么考虑什么时候这条语句会是**假话**

只有两种情况 $X$ 和 $Y$ 是同类 或者 $X$ 是 $Y$ 的食物

也就是说我们只需要判断 $X$ 和 $Y$ 是否在同一集合 $X$ 和 $Y + n$ 是否在同一集合即可

那么如果这条语句是**真话** 既然 $X$ 吃 $Y$

那么 $Y$ 的天敌类是 $X$ 同时由于题目告诉我们食物链构成大小为 $3$ 的环形 也就是说 $X$ 的天敌是 $Y$ 的食物

所以我们要将 $X + n$ 和 $Y$ 所在集合、$X$ 和 $Y + 2 \times n$ 所在集合、$X + 2 \times n $ 和 $Y + n$ 所在的集合合并即可

同时判断假话的时候注意一下边界条件($X$ 吃 $X$ $X$ 或 $Y$ 比 $N$)即可



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

//#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

#define lson(x) (x << 1)
#define rson(x) (x << 1 | 1)

inline int lowbit(int x) {
    return x & (-x);
}

inline ll ksm(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

constexpr int maxn = 2e5 + 10;
constexpr ll base = 131;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, m, f[maxn];

int find(int x) {
    return (f[x] == x ? x : f[x] = find(f[x]));
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    f[y] = x;
}

void solve(int id) {
    cin >> n >> m;
    for (int i = 1; i <= n * 3; i++) f[i] = i;
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        int op, x, y;
        cin >> op >> x >> y;
        if (x == y && op == 2 || x > n || y > n) {
            ans++;
            continue;
        }
        if (op == 1) {
            if (find(x) == find(y + n) || find(x) == find(y + 2 * n)) {
                ans++; continue;
            }
            merge(x, y);
            merge(x + n, y + n);
            merge(x + 2 * n, y + 2 * n);
        }
        if (op == 2) {
            if (find(x) == find(y) || find(x) == find(y + n)) {
                ans++; continue;
            }
            merge(x + n, y);
            merge(y + 2 * n, x);
            merge(y + n, x + 2 * n);
        }
    }
    cout << ans << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

