题目中描述的问题可以概括为两类

1.区间加

2.单点查询第一次 $\ge$ 某个值的时刻

首先考虑区间加和单点查询如何处理 我们很容易想到用树状数组来快速地维护

但是题目中的轨道是**环形**的 那么我们考虑破环成链

具体地说 对于一个给定的区间 $[l,r]$ 如果 $l\le r$ 那么我们不改变这个区间 否则 我们**让 $r$ 变为 $r + m$**

于是区间加操作搞定 变为了平凡的区间加操作

然后我们考虑对于 $2$ 操作如何处理

显然单点查询直接利用树状数组即可解决 

由于我们已经**破环成链**了 所以单点 $x$ 的值不仅对应了树状数组上 $x$ 位置的值 还对应了 $x + m$ 位置上的值

那么对于第一次 $>=$ 某个值的时刻 由于题目中保证了**区间加**的值为**正数**

所以 $\forall T\ge t$ ，一定保证 $T$ 时刻的值不小于 $t$ 时刻的值

于是我们可以采用二分来处理这些询问

然后我们发现 对于每一个询问都进行一遍二分复杂度过大 而**每次询问的二分范围相同** 且 **询问可以离线**

于是我们考虑采用整体二分来解决这个问题

若对于当前二分的时刻 $mid$ 位置 $p$ 上的值 $\ge$ 它的要求 那么就让他进左组 

否则就让他进右组 同时减去当前的值作为新的需求

然后考虑如何处理无解 一种较为简单的想法是 我们直接把二分的范围定为$1\textasciitilde k + 1$ 

这样一来 一旦 $k$ 作为答案都不满足的组 一定是无解的 它们就会进入 $k + 1$ 作为答案的组

输出时把 $k + 1$ 视作 $-1$ 即可



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;


int lowbit(int x) {
    return x & (-x);
}

constexpr int maxn = 6e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;

int n, m, k, M, l[maxn], r[maxn], ans[maxn], q[maxn], L[maxn], R[maxn];
ll tr[maxn], p[maxn], v[maxn];

vector<int> a[maxn];

void add(int x,ll y) {
    for (int i = x; i <= M; i += lowbit(i))
        tr[i] += y;
}

ll query(int x) {
    ll res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res += tr[i]; 
    return res;
}

void work(int ql, int qr, int cl, int cr) {
    if (ql > qr) return;
    if (cl == cr) {
        for (int i = ql; i <= qr; i++)
            ans[q[i]] = cl;
        return;
    }
    int mid = (cl + cr) / 2;
    for (int i = cl; i <= mid; i++)
        add(l[i], v[i]), add(r[i] + 1, -v[i]);
    int lnum = 0, rnum = 0;
    for (int i = ql; i <= qr; i++) {
        int num = q[i];
        ll cur = 0;
        bool flag = true;
        for (auto v : a[num]) {
            cur += query(v) + query(v + m);
            if (cur >= p[num]) {
                L[++lnum] = num;
                flag = false; break;
            }
        }
        if (flag) {
            p[num] -= cur;
            R[++rnum] = num;
        }
    }
    for (int i = 1; i <= lnum; i++) q[ql + i - 1] = L[i];
    for (int i = 1; i <= rnum; i++) q[ql + lnum + i - 1] = R[i];
    for (int i = cl; i <= mid; i++)
        add(l[i], -v[i]), add(r[i] + 1, v[i]);
    work(ql, ql + lnum - 1, cl, mid);
    work(ql + lnum, qr, mid + 1, cr);
}

void solve() {
    cin >> n >> m;
    M = m << 1;
    for (int i = 1; i <= m; i++) {
        int x; cin >> x;
        a[x].push_back(i);
    }
    for (int i = 1; i <= n; i++)
        cin >> p[i], q[i] = i;
    cin >> k;
    for (int i = 1; i <= k; i++) {
        cin >> l[i] >> r[i] >> v[i];
        if (r[i] < l[i]) r[i] += m;
    }
    work(1, n, 1, k + 1);
    for (int i = 1; i <= n; i++)
        if (ans[i] == k + 1) cout << "NIE\n";
        else cout << ans[i] << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

