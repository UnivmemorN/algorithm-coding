我们可以把路程分为两段 第一段是高海拔路段 通行无须代价 而第二段是低海拔代价 通行需要代价

于是我们的策略就是 先在高海拔路段行走一段距离 到达其中的一个点 $u$ 然后再从 $u$ 花费一定代价回到 $1$

显然每次我们要选择的 $u$ 都需要保证 $u$ 是所有当前高海拔节点中 到 $1$ 的距离最小的 

显然我们不能每次都跑一遍最短路 

但是我们发现节点 $1$ 是固定的 所以我们就可以以节点 $1$ 为起点 跑一遍最短路 就可以快速得到这个距离 记为 $dis$

由于我们已经知道了每个点到达 $1$ 的距离 所以问题就转换为了 从一个点 $v$ 出发 保证海拔必须 $> p $ 能够到达的点有哪些 

这是一个存在瓶颈的连通性问题 我们考虑建立 Kruskal 重构树来解决

我们按照海拔从大到小排序 建立出重构树

那么此时对于一个节点 $v$ 它的连通性就转换为了树上问题 

具体地说 我们需要让 $v$ 不断的向上跳 跳的过程中必须保证 $H[v] > p $ 其中 $H[v]$ 表示 $v$ 的海拔

最终 $v$ 所在的整棵子树 就是原图中 $v$ 所能到达的点 显然这个过程一步一步跳很慢 用树上倍增优化即可

然后我们就需要得到 $v$ 的整个子树内 $dis$ 的最小值 这是简单的

我们在建完树后跑 $dfs$ 的过程中 让父节点 $u$ 的距离和其所有子节点的距离取 $min$ 即可

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<cmath>
#include<cstring>
#include<string>
#include<set>
#include<unordered_set>
#include<unordered_map>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<climits>
#include<bitset>

using namespace std;

typedef long long ll;
constexpr int maxn = 4e5 + 10;
constexpr int N = 21;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 2e14;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

int n, m, f[maxn], cnt, dep[maxn], fa[maxn][N], H[maxn];
ll dis[maxn];
bool vis[maxn];
vector<pair<int, int>> edge[maxn];
vector<int> E[maxn];

struct node {
    int u, v, h;
} e[maxn];

void add(int u, int v, int w) {
    edge[u].push_back({ v,w });
}

void Add(int u, int v) {
    E[u].push_back(v);
}

int find(int x) {
    return(x == f[x] ? x : f[x] = find(f[x]));
}

bool cmp(node c1, node c2) {
    return c1.h > c2.h;
}

void dij() {
    priority_queue<pair<ll, int>> q;
    for (int i = 1; i <= n; i++) dis[i] = inf, vis[i] = 0;
    dis[1] = 0; q.push({ 0,1 });
    while (!q.empty()) {
        int u = q.top().second; q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto [v, w] : edge[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push({ -dis[v],v });
                }
            }
        }
    }
}

void ST() {
    for (int i = 1; i < N; i++)
        for (int u = 1; u <= cnt; u++)
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
}

void dfs(int u, int father) {
    dep[u] = dep[father] + 1;
    fa[u][0] = father;
    for (auto v : E[u]) {
        if (v == father) continue;
        dfs(v, u);
        dis[u] = min(dis[u], dis[v]);
    }
}

int jump(int v, int p) {
    int cur = v;
    for (int i = N - 1; i >= 0; i--)
        if (H[fa[v][i]] > p) v = fa[v][i];
    return v;
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        edge[i].clear();
    for (int i = 1; i <= m; i++) {
        int w;
        cin >> e[i].u >> e[i].v >> w >> e[i].h;
        add(e[i].u, e[i].v, w);
        add(e[i].v, e[i].u, w);
    }
    dij();
    sort(e + 1, e + m + 1, cmp);
    cnt = n;
    for (int i = 1; i <= n; i++) f[i] = i;
    for (int i = 1; i <= m; i++) {
        int u = find(e[i].u), v = find(e[i].v);
        if (u == v) continue;
        cnt++;
        f[cnt] = cnt;
        f[u] = f[v] = cnt;
        H[cnt] = e[i].h;
        Add(cnt, u);
        Add(cnt, v);
    }
    for (int i = n + 1; i <= cnt; i++) dis[i] = inf;
    for (int i = 1; i <= cnt; i++)
        if (find(i) == i)
            dfs(i, 0);
    ST();
    int Q, K, S;
    cin >> Q >> K >> S;
    ll lastans = 0;
    while (Q--) {
        int v0, p0;
        cin >> v0 >> p0;
        int v = ((v0 + K * lastans % n - 1) % n + n) % n + 1;
        int p = (p0 + K * lastans % (S + 1)) % (S + 1);
        int rt = jump(v, p);
        lastans = dis[rt];
        cout << lastans << "\n";
    }
    for (int i = 1; i <= cnt; i++) E[i].clear();
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    solve();
    return 0;
}
```
