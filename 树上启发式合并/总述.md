#  树上启发式合并 (DSU on Tree)

## 1. 核心思想: 优雅的暴力

树上启发式合并 (DSU on Tree) 是一种用于高效处理树上子树统计问题的离线算法.

你提到的"优雅的暴力"是对它核心思想的精彩概括:

- **暴力 (Brute Force):** 我们的目标是获取每个节点 $u$ 的子树的完整信息 (例如, 子树中每种颜色出现的次数). 最暴力的方法是, 对每个 $u$ 都遍历其所有子孙节点, 统计信息, 然后清空. 这样做的时间复杂度是 $O(N^2)$.
- **启发式 (Heuristic):** 算法的巧妙之处在于"启发式合并". 基于树的**重轻链剖分** (**Heavy-Light Decomposition**), 我们知道一个节点的"重儿子" (Heavy Son) 继承了其子树中"最多"的信息.
- **合并 (Merging):** 当我们计算完 $u$ 的所有子树后, 我们**只保留重儿子的统计信息**, 然后再"暴力"地将 $u$ 自身以及 $u$ 的所有"轻儿子" (Light Son) 的子树信息合并进来.

通过这种方式, 大部分信息 (重儿子的信息) 被直接继承, 只有小部分信息 (轻儿子的信息) 需要被重复计算. 这极大地优化了时间复杂度.

## 2. 适用场景



树上启发式合并主要用于解决**没有修改操作**的、**针对子树的静态查询**问题.

**典型特征:**

1. **静态问题:** 算法执行期间, 树的结构和节点信息不会发生改变.
2. **子树查询:** 所有查询都是针对某个节点 $u$ 的**整个子树** (subtree) 的.
3. **信息可合并:** 子树的信息可以通过遍历节点来累加或统计 (例如, 统计子树中出现次数最多的颜色, 统计子树中不同颜色的种数等).



## 3. 算法流程



算法分为两次 $dfs$ (深度优先搜索).



### 阶段一: $dfs1$ (预处理)



第一次 $dfs$ 的目的是预处理出后续计算所需要的信息:

1. `siz[u]`: 节点 $u$ 的子树大小.
2. `son[u]`: 节点 $u$ 的重儿子. 重儿子是 $u$ 的所有孩子中, `siz` 最大的那个. 如果有多个, 任选一个即可.



### 阶段二: $dfs2$ (启发式合并)



这是算法的核心. 我们需要一个**全局的数据结构** (如 `cnt[]` 数组或 `map`) 来实时统计当前"保留"的子树信息.

我们定义 `dfs2(u, fa, keep)`:

- `u`: 当前节点.
- `fa`: `u` 的父节点.
- `keep`: (布尔值) 标记是否保留 $u$ 子树的贡献.
  - `true`: 保留 (通常意味着 $u$ 是其父亲的重儿子).
  - `false`: 不保留 (清空).

**执行流程:**

1. 遍历轻儿子 (**不保留**):

   首先, 遍历 $u$ 的所有轻儿子 $v$, 并递归调用 `dfs2(v, u, false)`. `false` 参数保证了在轻儿子子树的答案计算完毕后, 其对全局数据结构 (如 $cnt[]$) 的贡献会被清空.

2. 遍历重儿子 (保留):

   接着, 遍历 $u$ 的重儿子 $son[u]$, 递归调用 `dfs2(son[u], u, true)`. `true` 参数保证了在重儿子子树计算完毕后, 其统计信息会被保留在全局数据结构中.

3. 合并 $u$ 和轻儿子子树:

   此时, 全局数据结构中只包含 $u$ 的重儿子子树的信息.

   - **添加 $u$ 自身:** 将 $u$ 节点本身的信息添加进全局数据结构
   - **添加所有轻儿子子树:** 再次遍历 $u$ 的所有**轻儿子** `v`, 并调用一个辅助函数 (如 `update(v, u)`) **将 v 的整个子树**的信息"暴力"添加进全局数据结构. (这个过程会暴力递归遍历 $v$ 的所有子孙节点, 并执行单点的更新操作).

4. 计算 $u$ 的答案:

   现在, 全局数据结构完整地包含了 $u$ 的整个子树 ( $u$ 自身 + 重儿子子树 + 所有轻儿子子树) 的信息. 此时, 我们可以回答关于 $u$ 的查询, 并将答案存储在 $ans[u]$ 中.

5. **清理 (根据 `keep` 标记):**

   - 如果 `keep == false` (即 $u$ 是一个轻儿子或根节点且不需要保留), 我们需要清空 $u$ 的整个子树对全局数据结构的贡献.
   - 这通常通过调用 `del(u, fa)` 来实现, "撤销" 步骤 $3$ 中所做的所有添加操作.
   - 如果 `keep == true`, 则不做任何操作, 将数据保留给 $u$ 的父节点使用.



## 4. 时间复杂度分析 $O(N \log N)$



树上启发式合并算法复杂度是由轻重儿子的定义保证的

- 算法的"暴力"操作在于 步骤 $3$ 和 $5$ , 即添加和删除轻儿子子树.
- 一个节点 $u$ 会被"暴力"访问多少次?
- 当 $u$ 位于一个重儿子的子树中时, 它的信息会被保留, 访问 $u$ 的开销是 $O(1)$ (均摊).
- 当 $u$ 位于一个轻儿子的子树中时, 它会被调用暴力访问子树时访问 (一次添加, 一次删除).
- 关键在于: **从任意节点 $u$ 到根节点的路径上, 最多只有 $O(\log N)$ 条轻边.**
- 因此, 任何一个节点 $u$ 最多只会作为 $O(\log N)$ 次 "轻子树" 的一部分被暴力统计.
- 假设处理单个节点  的复杂度是 $O(T)$, 那么总的时间复杂度就是 $O(N \cdot T \cdot \log N)$.
- 在大多数题目中, $T = O(1)$ (如数组) 或 $T = O(\log N)$ (如 `map` 或 `set`), 使得总复杂度通常为 $O(N \log N)$ 或 $O(N \log^2 N)$.





