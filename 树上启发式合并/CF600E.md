$CF600E$

离线静态无修改子树问题 容易想到树上启发式合并

要维护占重要地位的颜色编号之和 首先我们肯定要维护每种颜色出现的次数 $cnt$

然后对于以 $u$ 为根的子树 还需要维护子树内部颜色的最大出现次数 $maxcnt[u]$ 以及 答案 $ans[u]$

那么考虑当新的节点 $v$ 加入到 $u$ 子树的信息时 我们维护的信息该如何变化

首先 $cnt[col_v]++$ 

如果此时 $cnt[col_v] = maxcnt[u]$ 那么说明 $col_v$ 也是出现次数最大的颜色 $ans[u] += col_v$

否则如果 $cnt[col_v] > maxcnt[u]$ 那么说明 $col_v$ 成为了新的出现次数最大的颜色 $ans[u] = col_v$

在 `keep==0` 时 我们要消除 $u$ 这个节点的信息 直接清空即可 可以证明直接清空和一个一个删除的作用是相同的

代码如下 $: $

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long
typedef long long ll;

constexpr int maxn = 1e6 + 10;
constexpr int N = 23;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, col[maxn], siz[maxn], son[maxn], ans[maxn], maxcnt[maxn], cnt[maxn];

vector<int> edge[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void dfs1(int u, int fa) {
    siz[u] = 1;
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v])
            son[u] = v;
    }
}

void update(int u, int rt, int fa) {
    cnt[col[u]]++;
    if (cnt[col[u]] == maxcnt[rt]) ans[rt] += col[u];
    else if (cnt[col[u]] > maxcnt[rt]) {
        maxcnt[rt] = cnt[col[u]];
        ans[rt] = col[u];
    }
    for (auto v : edge[u]) {
        if (v == fa) continue;
        update(v, rt, u);
    }
}

void del(int u, int fa) {
    maxcnt[u] = 0;
    cnt[col[u]] = 0;
    for (auto v : edge[u]) {
        if (v == fa) continue;
        del(v, u);
    }
}

void dfs2(int u, int fa,int keep) {
    for (auto v : edge[u]) {
        if (v == fa || v == son[u]) continue;
        dfs2(v, u, 0);
    }
    if (son[u]) {
        dfs2(son[u], u, 1);
        ans[u] = ans[son[u]];
        maxcnt[u] = maxcnt[son[u]];
    }
    cnt[col[u]]++;
    if (cnt[col[u]] == maxcnt[u]) ans[u] += col[u];
    else if (cnt[col[u]] > maxcnt[u]) {
        maxcnt[u] = cnt[col[u]];
        ans[u] = col[u];
    }
    for (auto v : edge[u]) {
        if (v == fa || v == son[u]) continue;
        update(v, u, u);
    }
    if (keep == 0) del(u, fa);
}

void solve(int id){
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> col[i];
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 0, 0);
    for (int i = 1; i <= n; i++)
        cout << ans[i] << " ";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

