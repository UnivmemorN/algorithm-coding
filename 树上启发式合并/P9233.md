询问**子树** 同时**没有修改**的**离线**问题 考虑**树上启发式合并**

关键在于如何处理 所谓的"每种颜色出现次数都相同"

实际上我们可以维护每一个颜色的**出现次数** $f[color]$ 以及**出现次数为 $cnt$ 的颜色有几种 ** $g[cnt]$

倘若某一棵以 $u$ 为根的子树是颜色平衡树 假设它的颜色为 $col_u$ 其子树大小为 $siz[u]$

那么我们一定有 $f[col_u] \times g[f[col_u]] = siz[u]$ 反之则一定不成立

于是我们就将该问题转化为了一个统计子树上某种颜色出现次数以及每种出现次数有几个的问题

这个问题显然是可以利用启发式合并求解的

代码如下 $:$



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 1e6 + 10;
constexpr int N = 23;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, col[maxn], siz[maxn], son[maxn], f[maxn], g[maxn], ans;

vector<int> edge[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void dfs1(int u) {
    siz[u] = 1;
    for (auto v : edge[u]) {
        dfs1(v);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]])
            son[u] = v;
    }
}

void update(int u) {
    f[col[u]]++;
    g[f[col[u]] - 1]--;
    g[f[col[u]]]++;
    for (auto v : edge[u]) 
        update(v);
}

void del(int u) {
    f[col[u]]--;
    g[f[col[u]] + 1]--;
    g[f[col[u]]]++;
    for (auto v : edge[u])
        del(v);
}

void dfs2(int u, int keep) {
    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        dfs2(v, 0);
    }
    if (son[u]) dfs2(son[u], 1);
    f[col[u]]++;
    g[f[col[u]] - 1]--;
    g[f[col[u]]]++;

    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        update(v);
    }
    if (f[col[u]] * g[f[col[u]]] == siz[u]) ans++;
    if (keep == 0) del(u);
}

void solve(int id){
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int fa;
        cin >> col[i] >> fa;
        add(fa, i);
    }
    dfs1(1);
    dfs2(1, 0);
    cout << ans << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```



