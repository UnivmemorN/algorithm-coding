一个很显然的事实是 当 $K$ 的值逐渐上升 答案 $ans$ 的值单调不增

既然我们已知单调不增 那么我们考虑 $ans$ 的值下降的幅度

我们可以以 $1$ 和 $\sqrt{N}$ 为分界线来讨论

为什么呢 

因为当 $K = 1$ 的时候 $ans = N$

而如果 $K = \sqrt{N}$ 时 $ans \le \sqrt{N}$

证明是简单的 $:$ 假设 $K = \sqrt{N}$ 那么就算每一个小组内部的所有数字全部不同 我们要分的组数也就只有 $\frac{N}{\sqrt{N}} = \sqrt{N}$

那么也就意味着只要有相同值 $ans$ 就有可能 $\le \sqrt{N}$ 所以 $ans\le\sqrt{N}$ 是成立的

这就是说 当 $K$ 从 $1$ 增长到 $\sqrt{N}$ 的时候 答案会从 $N$ 降低到 $\sqrt{N}$ 附近 

而当 $K$ 从 $\sqrt{N}$ 增长到 $N$ 的时候 答案只会从 $\sqrt{N}$ 附近降低到 $1$

这表明 在 $K$ 从 $\sqrt{N}$ 到 $N$ **这一长度很大的范围内 出现的答案个数很少**

也就是大部分**连续的 $K$ 的答案是同一个值**

那么我们就可以利用根号分治来讨论了

当 $K \le \sqrt{N}$ 时 我们直接暴力去模拟分组             该部分时间复杂度为 $O(N\sqrt{N})$

而当 $K\ge \sqrt{N}$ 时 我们只需要求出**某几个分界点的 $ans$ 值** 然后利用**二分**去寻找答案为 $ans$ 的 $K$ 的最大值 $R$ 是谁 

再让新的 $K$ 从 $R + 1$ 开始继续作为分界点 二分求解右边界 重复即可                  该部分时间复杂度为 $O(N\sqrt{N}\log N)$



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9 + 1e8;

constexpr int maxn = 1e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };
//these primes' product > 1e16

int n, a[maxn], f[maxn], B, ans[maxn];

int query(int x) {
    int cur = 0, lst = 1, sum = 1;
    for (int i = 1; i <= n; i++) {
        if (!f[a[i]]) {
            cur++;
            if (cur > x) {
                sum++;
                for (int j = lst; j < i; j++)
                    f[a[j]] = 0;
                cur = 1;
                lst = i;
            }
            f[a[i]] = 1;
        }
    }
    for (int i = lst; i <= n; i++) f[a[i]] = 0;
    return sum;
}

int jump(int l, int r, int x) {
    int ans = l;
    while (l <= r) {
        int mid = (l + r) / 2;
        int cur = query(mid);
        if (cur == x) {
            ans = mid;
            l = mid + 1;
        }
        else if (cur > x) l = mid + 1;
        else r = mid - 1;
    }
    return ans;
}

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    B = sqrt(n);
    for (int i = 1; i <= B; i++)
        ans[i] = query(i);
    for (int i = B + 1; i <= n; i = jump(i,n,ans[i]) + 1) 
        ans[i] = query(i);
    for (int i = 1; i <= n; i++) {
        if (ans[i] == 0) ans[i] = ans[i - 1];
        cout << ans[i] << " ";
    }
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

