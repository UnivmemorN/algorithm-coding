首先我们观察到 如果 $k$ 不断增大 那么答案值 $ans$ 一定单调不增

然后 如果 $k = 1$ 那么答案一定为 $n$ 因为每个点作为一条路径

而如果 $k = n$ 那么 $ans \le 1$ 这是因为如果 $n$ 个点形成了一条链 那么 $ans = 1$ 否则 $ans = 0$

然后我们考虑 $k = \sqrt{n}$ 的情况 这种情况下 就算每 $k$ 个节点都刚好形成一条路径 那么 $ans = \frac{n}{\sqrt{n}} = \sqrt{n}$ 否则 $ans$ 必定 $<\sqrt{n}$

所以在 $k$ 从 $1\to\sqrt{n}$ 的过程中 $ans$ 从 $n\to\sqrt{n}$ 而 $k$ 从 $\sqrt{n}\to n$ 的过程中 $ans$ 从 $\sqrt{n}\to1$

也就是说在从 $\sqrt{n}\to n$ 这一很长的距离中 仅有 $\sqrt{n}$ 个有效的答案 那么我们就可以按照之前 $(CF786)$ 的做法

使用根号分治 在 $k\le\sqrt{n}$ 的时候直接暴力求解

而在 $k > \sqrt{n}$ 时 枚举答案为 $ans$ 时候的左端点 二分找到右端点不断重复这个过程即可

至于如何求出路径数 我们利用 $dfs$ 序优化树形 $DP$

对于每一个点 $u$ 保存三个值 `MAX1、MAX2、len` 分别表示经过 $u$ 的最长路径的距离 次长路径的距离和其能向父亲贡献的最大长度

首先初始化 三者均为 $0$ 我们设当前统计 $k = x$ 时的答案 `ans`

然后对于一个点 $u$ 如果 `MAX1[u] + MAX2[u] + 1 >= x` 那么直接 `ans++` 同时把 `len[u]` 设为 $0$ 因为其已经和子节点连接起来成为一条路径了 根据题目要求 它不能再给父亲贡献了

否则 `len[u] = MAX1[u] + 1` 同时用 `len[u]` 尝试更新 `MAX1[fa]` 和 `MAX2[fa]`

最终的 `ans` 值就是我们要求的答案



代码如下 $:$



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9 + 1e8;


constexpr int maxn = 2e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };
//these primes' product > 1e16

int n, dfn[maxn], seg[maxn], tim, ans[maxn], father[maxn], MAX1[maxn], MAX2[maxn], len[maxn];
int to[maxn], nxt[maxn], head[maxn], cnt;

void add(int u, int v) {
    to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt;
}

void dfs(int u, int fa) {
    dfn[u] = ++tim; seg[tim] = u;
    father[u] = fa;
    for (int i = head[u]; i ; i = nxt[i]){
        int v = to[i];
        if (v == fa) continue;
        dfs(v, u);
    }
}

int query(int x) {
    int ans = 0;
    for (int i = 1; i <= n; i++) MAX1[i] = MAX2[i] = len[i] = 0;
    for (int i = n; i >= 1; i--) {
        int u = seg[i], fa = father[u];
        if (MAX1[u] + MAX2[u] + 1 >= x) {
            ans++;
            len[u] = 0;
        }
        else len[u] = MAX1[u] + 1;
        if (len[u] > MAX1[fa]) {
            MAX2[fa] = MAX1[fa];
            MAX1[fa] = len[u];
        }
        else if (len[u] > MAX2[fa]) MAX2[fa] = len[u];
    }
    return ans;
}

int jump(int l, int r, int x) {
    int ans = l;
    while (l <= r) {
        int mid = (l + r) / 2;
        int cur = query(mid);
        if (cur < x) r = mid - 1;
        else if (cur == x) ans = mid, l = mid + 1;
        else l = mid + 1;
    }
    return ans + 1;
}

void solve() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs(1, 0);
    int B = sqrt(n);
    for (int i = 1; i <= n; i++) ans[i] = -1;
    for (int i = 1; i <= B; i++)
        ans[i] = query(i);
    for (int i = B + 1; i <= n; i = jump(i, n, ans[i]))
        ans[i] = query(i);
    for (int i = 1; i <= n; i++) {
        if (ans[i] == -1) ans[i] = ans[i - 1];
        cout << ans[i] << "\n";
    }
    
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

