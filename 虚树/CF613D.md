

注意到题目中的 “重要城市” 以及 $\sum k_i \le 10^5$  同时题目给的结构是一棵树 容易想到虚树

首先考虑何时无解 答案是显然的 如果有相邻的两个节点都是关键点 那么无解 

那么其他情况下都是有解的 本题不要求 $1$ 号节点一定要在虚树内 所以无需考虑

我们先按照方法建立出虚树 然后考虑树形 $DP$

我们用 $g[u]$ 表示 $u$ 的子树内还有多少个关键节点 $cost[u]$ 表示 $u$ 子树满足条件的最小代价

假设当前节点为 $u$ 子节点为 $v_i$ 

那我们当前考虑的就是删除 $u$ 和 $v$ 之间的点 

为什么说 $u$ 和 $v$ 之间一定有节点呢 因为假设 $u$ 和 $v$ 之间没有节点 那么 $u$ 和 $v$ 必定是相邻的 

而一旦 $u$ 和 $v$ 相邻 若它们均为关键点 那么一定是矛盾的 在判断是否有解时就已经被处理掉了

若它们不均为关键点 那么一定可以删除其中某一个节点

所以 $u$ 和 $v$ 之间一定有节点能删

所以当我们考虑 $u$ 的时候 任何一个 $v_i$ 的子树状态均不会发生改变 

而 $g[v]$ 和 $cost[v]$ 都是符合题意下的状态 那么显然 $g[v] \le 1$ 

因为假设 $g[v] = 2$ 说明内部有两个关键节点 它们一定是可以互相抵达的 但是 $v$ 的子树上的关键节点

那么首先有 $g[u] = \sum g[v_i],cost[u] = \sum cost[v_i]$ 

接下来 分类讨论

假设 $u$ 是一个关键节点 

那么应当切断 $u$ 和其所有还含有关键节点儿子的关联 也就是 $u$ 要切断所有 $g[v] = 1$ 的个数 而它无法切断它自己

所以显然有 $cost[u] += g[u],g[u] = 1$

假设 $u$ 不是一个关键节点

那么要继续分类讨论 假设 $g[u] > 1$ 那么显然删除 $u$ 自己是最优的 $cost[u] +=1,g[u] = 0 $

否则 $g[u] \le 1$ 那么 $u$ 节点保持不动即可 让父节点去抉择 $u$ 的状态

若 $g[u] = 0$ 已经没有了关键节点 那么显然不用动 

若 $g[u] = 1$ 那么 $u$ 也可以暂时保持不动 这样已经符合条件了 对于 $u$ 来说必定最优



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr int mod = 998244353;

constexpr int maxn = 2e5 + 10;
constexpr int N = 21;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };


int n, dfn[maxn], tim, f[maxn][N], dep[maxn], key[maxn], a[maxn], cnt, cost[maxn], g[maxn];
bool iskey[maxn];
vector<int> edge[maxn], to[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v];
    for (int i = N - 1; i >= 0; i--)
        if ((k >> i) & 1) u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}

void dfs(int u, int fa) {
    dfn[u] = ++tim;
    f[u][0] = fa;
    dep[u] = dep[fa] + 1;
    for (int i = 1; i < N; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

bool cmp(int x, int y) {
    return dfn[x] < dfn[y];
}

void dp(int u) {
    cost[u] = g[u] = 0;
    for (auto v : to[u]) {
        dp(v);
        cost[u] += cost[v];
        g[u] += g[v];
    }
    if (iskey[u]) {
        cost[u] += g[u];
        g[u] = 1;
    }
    else if (g[u] > 1) {
        cost[u]++;
        g[u] = 0;
    }
}

void solve(int id) {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs(1, 0);
    int Q;
    cin >> Q;
    while (Q--) {
        int k;
        cin >> k;
        cnt = 0;
        for (int i = 1; i <= k; i++)
            cin >> key[i], iskey[key[i]] = 1, a[++cnt] = key[i];
        sort(a + 1, a + cnt + 1, cmp);
        bool flag = true;
        for (int i = 1; i <= k; i++)
            if (iskey[f[a[i]][0]]) {
                flag = false; break;
            }
        for (int i = 1; i < k; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            a[++cnt] = lca;
        }
        sort(a + 1, a + cnt + 1, cmp);
        cnt = unique(a + 1, a + cnt + 1) - a - 1;
        for (int i = 1; i < cnt; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            to[lca].push_back(v);
        }
        if (!flag) 
            cout << -1 << "\n";
        else {
            dp(a[1]);
            cout << cost[a[1]] << "\n";
        }
        for (int i = 1; i < cnt; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            to[lca].clear();
        }
        for (int i = 1; i <= k; i++)
            iskey[key[i]] = 0;
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```



