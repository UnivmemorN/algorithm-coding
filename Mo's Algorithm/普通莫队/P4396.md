题目所问的问题是有关区间查询出现次数的 容易想到莫队

由于题目中问数值 $\ge a$ 且 $\le b$ 的个数 而普通的莫队只能统计单个数出现的次数

所以我们考虑对值域也进行分块 , 用来维护区间内出现的次数

具体地说 , 因为块间操作和块内操作的常数复杂度差异并不大 , 我们不妨将块长定为 $\sqrt{V}$ 

当一个数字 $x$ 出现(区间扩张)时 首先我们记录他的出现次数 $h[x]+1$  这是用来解决题目中 **出现过数值的个数** 这个问题的

如果 $h[x] = 1$  那么表示 $x$ 这个数是第 $1$ 次出现 出现过数值的个数应该增加 

为了避免暴力的寻找 $[a,b]$ 区间的出现次数 此时我们要对于块操作 也就是我们得到 $x$ 所在的块的编号 $block$ 让 $fblock[block] + 1$ 来表示该块中出现过数值的个数增加 $1$

其次我们要让 $f[block] + 1$ 表示 $block$ 这个块又增加了一个数

相应的 当一个数字消失(区间收缩)时 我们要让 $h[x] - 1$ 当 $h[x] == 0$ 的时候 要让 $fblock[block] - 1$ 同时 $f[block] - 1$

那么在查询时，假设我们要查询的是从 $[x,y]$ 区间(也就是原题中的 $[a,b]$ 但是变量名用 $x,y$ 更好)

我们需要得到 $x$ 所在块号 $bx$ 和 $y$ 所在块号 $by$

如果 $bx = by$ 那么询问区间在同一块中 直接从 $x$ 到 $y$ 遍历即可

否则 我们要遍历的是 $bx + 1$ 到 $by - 1$ 这些整块 直接得到 $flobck[block]$ 和 $f[block]$

而 $x$ 和 $y$ 所在的块是散块 直接遍历即可 $x$ 所在块我们从 $x$ 到其块的右端点 而 $y$ 所在的块我们从其块左端点遍历到 $y$ 即可



代码如下 : 

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

//#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 1e9 + 7;

constexpr int maxn = 2e5 + 10;
int n, m, V = 100000, d = sqrt(V), v[maxn], block[maxn], br[maxn];
int f[maxn], fblock[maxn], h[maxn];

int ans[maxn][2];


struct node {
    int l, r, x, y, bl, id;
} q[maxn];

bool cmp(node c1, node c2) {
    if (c1.bl == c2.bl) {
        if (c1.bl & 1) return c1.r < c2.r;
        return c1.r > c2.r;
    }
    return c1.bl < c2.bl;
}

void add(int x) {
    h[x]++;
    int p = block[x];
    f[p]++;
    if (h[x] == 1) fblock[p]++;
}

void del(int x) {
    h[x]--;
    int p = block[x];
    f[p]--;
    if (h[x] == 0) fblock[p]--;
}

void solve(int id) {
    cin >> n >> m;
    int B = sqrt(n);
    for (int i = 1; i <= n; i++) cin >> v[i];
    for (int i = 1; i <= m; i++) {
        int l, r, x, y;
        cin >> l >> r >> x >> y;
        q[i] = { l,r,x,y,(l - 1) / B + 1,i };
    }
    sort(q + 1, q + m + 1, cmp);
    for (int i = 1; i <= V; i++) block[i] = (i - 1) / d + 1;
    int blockNum = (V - 1) / d + 1;
    for (int i = 1; i <= blockNum; i++)
        br[i] = min(V, i * d);
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        while (l > q[i].l) add(v[--l]);
        while (r < q[i].r) add(v[++r]);
        while (l < q[i].l) del(v[l++]);
        while (r > q[i].r) del(v[r--]);
        int x = q[i].x, y = q[i].y;
        int bx = block[x], by = block[y];
        int ans1 = 0, ans2 = 0;
        if (bx == by) {
            for (int j = x; j <= y; j++) {
                if (h[j] > 0) ans2++;
                ans1 += h[j];
            }
        }
        else {
            for (int j = bx + 1; j <= by - 1; j++)
                ans1 += f[j], ans2 += fblock[j];
            for (int j = x; j <= br[bx]; j++) {
                if (h[j] > 0) ans2++;
                ans1 += h[j];
            }
            for (int j = br[by - 1] + 1; j <= y; j++) {
                if (h[j] > 0) ans2++;
                ans1 += h[j];
            }
        }
        ans[q[i].id][0] = ans1;
        ans[q[i].id][1] = ans2;
    }
    for (int i = 1; i <= m; i++)
        cout << ans[i][0] << " " << ans[i][1] << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

