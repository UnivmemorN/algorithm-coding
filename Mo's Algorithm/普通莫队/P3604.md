$P3604$

要让区间内的字符重排之后能够成为一个回文串 那么该区间内字符出现次数为奇数字符个数 $\le 1$

由于字符集只有 $a-z$ 这 $26$ 个字母 所以我们考虑直接状压压缩 用一个二进制串 $S$ 表示当前字符串的每个字母的奇偶性 $S_i = 1$ 表明第 $i$ 种字母(记 $a$ 为第 $0$ 种字母)出现次数为奇数 否则出现次数为偶数0

然后我们采用一个很经典的做法 $: $

当询问 $[l,r]$ 区间时 我们可以让右端点从 $l$ 开始移动到 $r$ 统计每一个右端点对应的**符合题意的左端点**有几个 

那么在这道题目中 对于一个右端点 $R$ **符合题意的左端点** $L$ 满足的条件显然是 $S_R \oplus S_{L - 1}$ 的 $1$ 的个数 $\le 1$

如此一来 , 我们用一个数组 $f$ 来表示某一个状态 $S$ 出现的次数 对于一个 $R$  想要求出符合题意的 $L$ 数量

也就是将所有 $S_R \oplus S_{L - 1}$ 的 $1$ 的个数 $\le 1$ 累加 也即 $S_{L - 1} = S_R$ 或 $S_{L - 1} = S_R \oplus (2^k)$ 其中 $0\le k\le25$

而 $f$ 数组恰好记录了满足条件的 $S_{L-1}$ 的数目 用一个循环累加即可

这个过程完美地将原问题转化为区间出现次数类的问题 用莫队即可解决

另外需要注意的是由于 $L - 1$ 可能会涉及到 $0$ 所以我们将所有数的下标全部 $+1$ 来避免这个问题



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 998244353;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-7;
constexpr int intinf = 1e9 + 10;

#define lson(x) (x << 1)
#define rson(x) (x << 1 | 1)

constexpr int maxn = 6e4 + 10;
constexpr int N = 23;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };
//these primes' product > 1e16

int n, m, st[maxn], cnt, f[(1 << 26)];
ll res[maxn],ans;
string s;

struct node {
    int l, r, bl, id;
} q[maxn];

bool cmp(node c1, node c2) {
    if (c1.bl == c2.bl) {
        if (c1.bl & 1) return c1.r < c2.r;
        return c1.r > c2.r;
    }
    return c1.bl < c2.bl;
}

void add(int x) {
    ans += f[x];
    for (int i = 0; i < 26; i++)
        ans += (f[x ^ (1 << i)]);
    f[x]++;
}

void del(int x) {
    f[x]--;
    ans -= f[x];
    for (int i = 0; i < 26; i++)
        ans -= (f[x ^ (1 << i)]);
}

void solve(int id) {
    cin >> n >> m;
    cnt = 1;
    st[0] = 0;
    for (int i = 1; i <= n; i++) {
        char c; cin >> c;
        st[++cnt] = st[cnt - 1] ^ (1 << (c - 97));
    }
    int B = sqrt(n + 1);
    for (int i = 1; i <= m; i++) {
        int l, r;
        cin >> l >> r;
        r++;
        q[i] = { l,r,(l - 1) / B + 1,i };
    }
    sort(q + 1, q + m + 1, cmp);
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        while (l > q[i].l) add(st[--l]);
        while (r < q[i].r) add(st[++r]);
        while (l < q[i].l) del(st[l++]);
        while (r > q[i].r) del(st[r--]);
        res[q[i].id] = ans;
    }
    for (int i = 1; i <= m; i++)
        cout << res[i] << "\n";
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    while (T--) {
        solve(T);
    }
    return 0;
}
```

